name: Build FFmpeg AAR for Android ARM64

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  ANDROID_NDK_VERSION: "26.1.10909125"
  ANDROID_API_LEVEL: "24"
  FFMPEG_VERSION: "6.1"
  ANDROID_ABI: "arm64-v8a"
  GRADLE_VERSION: "8.4"
  AGP_VERSION: "8.1.4"
  
jobs:
  build-ffmpeg-aar:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Setup Android SDK
      uses: android-actions/setup-android@v3
      
    - name: Install Android NDK
      run: |
        yes | sdkmanager --install "ndk;${{ env.ANDROID_NDK_VERSION }}"
        echo "ANDROID_NDK_ROOT=$ANDROID_SDK_ROOT/ndk/${{ env.ANDROID_NDK_VERSION }}" >> $GITHUB_ENV
        echo "ANDROID_NDK_HOME=$ANDROID_SDK_ROOT/ndk/${{ env.ANDROID_NDK_VERSION }}" >> $GITHUB_ENV
        
    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          git \
          pkg-config \
          yasm \
          nasm \
          autoconf \
          automake \
          libtool \
          wget \
          curl \
          unzip \
          python3 \
          python3-pip \
          ninja-build
          
    - name: Create build directories
      run: |
        mkdir -p build/{src,external-libs,ffmpeg-deps,output,toolchain}
        mkdir -p build/ffmpeg-deps/{include,lib,lib/pkgconfig}
        mkdir -p build/output/ffmpeg/{include,lib}
        
    - name: Set up cross-compilation environment
      run: |
        export ANDROID_NDK_ROOT="${{ env.ANDROID_NDK_ROOT }}"
        export TOOLCHAIN_ROOT="$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64"
        export TARGET="aarch64-linux-android"
        export API="${{ env.ANDROID_API_LEVEL }}"
        
        echo "ANDROID_NDK_ROOT=$ANDROID_NDK_ROOT" >> $GITHUB_ENV
        echo "TOOLCHAIN_ROOT=$TOOLCHAIN_ROOT" >> $GITHUB_ENV
        echo "TARGET=$TARGET" >> $GITHUB_ENV
        echo "API=$API" >> $GITHUB_ENV
        echo "SYSROOT=$TOOLCHAIN_ROOT/sysroot" >> $GITHUB_ENV
        echo "AR=$TOOLCHAIN_ROOT/bin/llvm-ar" >> $GITHUB_ENV
        echo "CC=$TOOLCHAIN_ROOT/bin/$TARGET$API-clang" >> $GITHUB_ENV
        echo "CXX=$TOOLCHAIN_ROOT/bin/$TARGET$API-clang++" >> $GITHUB_ENV
        echo "LD=$TOOLCHAIN_ROOT/bin/ld" >> $GITHUB_ENV
        echo "RANLIB=$TOOLCHAIN_ROOT/bin/llvm-ranlib" >> $GITHUB_ENV
        echo "STRIP=$TOOLCHAIN_ROOT/bin/llvm-strip" >> $GITHUB_ENV
        echo "NM=$TOOLCHAIN_ROOT/bin/llvm-nm" >> $GITHUB_ENV
        echo "STRINGS=$TOOLCHAIN_ROOT/bin/llvm-strings" >> $GITHUB_ENV
        echo "OBJDUMP=$TOOLCHAIN_ROOT/bin/llvm-objdump" >> $GITHUB_ENV
        echo "FFMPEG_DEPS_ROOT=$(pwd)/build/ffmpeg-deps" >> $GITHUB_ENV
        echo "FFMPEG_PREFIX=$(pwd)/build/output/ffmpeg" >> $GITHUB_ENV
        
    - name: Build libogg (dependency for vorbis)
      run: |
        cd build/src
        git clone --depth 1 --branch v1.3.5 https://github.com/xiph/ogg.git
        cd ogg
        ./autogen.sh
        ./configure \
          --host=aarch64-linux-android \
          --disable-shared \
          --enable-static \
          --prefix="$FFMPEG_DEPS_ROOT" \
          AR="$AR" \
          CC="$CC" \
          CXX="$CXX" \
          RANLIB="$RANLIB" \
          STRIP="$STRIP"
        make -j$(nproc)
        make install
        
    - name: Build x264
      run: |
        cd build/src
        git clone --depth 1 --branch stable https://code.videolan.org/videolan/x264.git
        cd x264
        ./configure \
          --host=aarch64-linux-android \
          --cross-prefix="$TOOLCHAIN_ROOT/bin/llvm-" \
          --sysroot="$SYSROOT" \
          --enable-static \
          --enable-pic \
          --disable-cli \
          --disable-asm \
          --prefix="$FFMPEG_DEPS_ROOT" \
          --extra-cflags="-fPIC" \
          --extra-ldflags="-fPIC"
        make -j$(nproc)
        make install
        
    - name: Build libopus
      run: |
        cd build/src
        git clone --depth 1 --branch v1.4 https://github.com/xiph/opus.git
        cd opus
        ./autogen.sh
        ./configure \
          --host=aarch64-linux-android \
          --disable-shared \
          --enable-static \
          --disable-doc \
          --disable-extra-programs \
          --prefix="$FFMPEG_DEPS_ROOT" \
          AR="$AR" \
          CC="$CC" \
          CXX="$CXX" \
          RANLIB="$RANLIB" \
          STRIP="$STRIP"
        make -j$(nproc)
        make install
        
    - name: Build libvorbis
      run: |
        cd build/src
        export PKG_CONFIG_PATH="$FFMPEG_DEPS_ROOT/lib/pkgconfig:$PKG_CONFIG_PATH"
        git clone --depth 1 --branch v1.3.7 https://github.com/xiph/vorbis.git
        cd vorbis
        ./autogen.sh
        ./configure \
          --host=aarch64-linux-android \
          --disable-shared \
          --enable-static \
          --disable-docs \
          --disable-examples \
          --prefix="$FFMPEG_DEPS_ROOT" \
          --with-ogg="$FFMPEG_DEPS_ROOT" \
          AR="$AR" \
          CC="$CC" \
          CXX="$CXX" \
          RANLIB="$RANLIB" \
          STRIP="$STRIP"
        make -j$(nproc)
        make install
        
    - name: Build libmp3lame
      run: |
        cd build/src
        wget -O lame-3.100.tar.gz "https://downloads.sourceforge.net/project/lame/lame/3.100/lame-3.100.tar.gz"
        tar -xzf lame-3.100.tar.gz
        cd lame-3.100
        ./configure \
          --host=aarch64-linux-android \
          --disable-shared \
          --enable-static \
          --disable-frontend \
          --prefix="$FFMPEG_DEPS_ROOT" \
          AR="$AR" \
          CC="$CC" \
          CXX="$CXX" \
          RANLIB="$RANLIB" \
          STRIP="$STRIP"
        make -j$(nproc)
        make install

    - name: Verify external libraries installation
      run: |
        echo "Verifying external libraries installation..."
        
        # Check library files exist
        echo "Static libraries in $FFMPEG_DEPS_ROOT/lib:"
        ls -la "$FFMPEG_DEPS_ROOT/lib"/*.a 2>/dev/null || echo "No .a files found"
        
        # Check headers exist
        echo "Headers in $FFMPEG_DEPS_ROOT/include:"
        find "$FFMPEG_DEPS_ROOT/include" -name "*.h" | head -10 || echo "No headers found"
        
        # Check pkg-config files
        echo "pkg-config files:"
        ls -la "$FFMPEG_DEPS_ROOT/lib/pkgconfig"/*.pc 2>/dev/null || echo "No .pc files found"
        
        # Test pkg-config
        export PKG_CONFIG_PATH="$FFMPEG_DEPS_ROOT/lib/pkgconfig:$PKG_CONFIG_PATH"
        for lib in ogg opus vorbis x264; do
          if pkg-config --exists "$lib" 2>/dev/null; then
            echo "$lib: FOUND (version: $(pkg-config --modversion "$lib" 2>/dev/null || echo 'unknown'))"
          else
            echo "$lib: NOT FOUND via pkg-config"
          fi
        done

    - name: Download and build FFmpeg
      run: |
        cd build/src
        
        # Set up environment for external libraries
        export PKG_CONFIG_PATH="$FFMPEG_DEPS_ROOT/lib/pkgconfig:$PKG_CONFIG_PATH"
        export CPPFLAGS="-I$FFMPEG_DEPS_ROOT/include"
        export LDFLAGS="-L$FFMPEG_DEPS_ROOT/lib"
        
        echo "Downloading FFmpeg ${{ env.FFMPEG_VERSION }}..."
        wget -O ffmpeg-${{ env.FFMPEG_VERSION }}.tar.xz "https://ffmpeg.org/releases/ffmpeg-${{ env.FFMPEG_VERSION }}.tar.xz"
        tar -xf ffmpeg-${{ env.FFMPEG_VERSION }}.tar.xz
        cd ffmpeg-${{ env.FFMPEG_VERSION }}
        
        echo "Configuring FFmpeg with external codec support..."
        ./configure \
          --cross-prefix="$TOOLCHAIN_ROOT/bin/llvm-" \
          --sysroot="$SYSROOT" \
          --target-os=android \
          --arch=aarch64 \
          --cpu=armv8-a \
          --cc="$CC" \
          --ar="$AR" \
          --ranlib="$RANLIB" \
          --strip="$STRIP" \
          --nm="$NM" \
          --enable-cross-compile \
          --enable-gpl \
          --disable-shared \
          --enable-static \
          --enable-small \
          --disable-programs \
          --disable-doc \
          --disable-htmlpages \
          --disable-manpages \
          --disable-podpages \
          --disable-txtpages \
          --disable-network \
          --disable-protocols \
          --enable-protocol=file \
          --enable-protocol=pipe \
          --enable-libx264 \
          --enable-libopus \
          --enable-libvorbis \
          --enable-libmp3lame \
          --enable-encoder=libx264 \
          --enable-encoder=libopus \
          --enable-encoder=libvorbis \
          --enable-encoder=libmp3lame \
          --enable-encoder=aac \
          --enable-decoder=h264 \
          --enable-decoder=libopus \
          --enable-decoder=vorbis \
          --enable-decoder=mp3 \
          --enable-decoder=aac \
          --enable-parser=h264 \
          --enable-parser=aac \
          --enable-demuxer=mov \
          --enable-demuxer=mp4 \
          --enable-demuxer=avi \
          --enable-demuxer=wav \
          --enable-demuxer=ogg \
          --enable-muxer=mp4 \
          --enable-muxer=mov \
          --enable-muxer=avi \
          --enable-muxer=wav \
          --enable-muxer=ogg \
          --extra-cflags="-I$FFMPEG_DEPS_ROOT/include -fPIC -DANDROID -D__ANDROID_API__=$API" \
          --extra-ldflags="-L$FFMPEG_DEPS_ROOT/lib" \
          --extra-libs="-lx264 -lopus -lvorbis -lvorbisenc -logg -lmp3lame -lm" \
          --prefix="$FFMPEG_PREFIX" \
          2>&1 | tee configure.log
          
        CONFIGURE_EXIT_CODE=${PIPESTATUS[0]}
        
        if [ $CONFIGURE_EXIT_CODE -ne 0 ]; then
          echo "=== CONFIGURE FAILED ==="
          echo "Last 50 lines of configure log:"
          tail -50 configure.log
          
          echo "=== Config log (last 50 lines) ==="
          if [ -f "ffbuild/config.log" ]; then
            tail -50 ffbuild/config.log
          fi
          
          echo "=== Environment debug ==="
          echo "PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          echo "CPPFLAGS: $CPPFLAGS"
          echo "LDFLAGS: $LDFLAGS"
          
          # Try fallback configuration without problematic external codecs
          echo "Attempting fallback configuration..."
          make distclean 2>/dev/null || true
          
          ./configure \
            --cross-prefix="$TOOLCHAIN_ROOT/bin/llvm-" \
            --sysroot="$SYSROOT" \
            --target-os=android \
            --arch=aarch64 \
            --cpu=armv8-a \
            --cc="$CC" \
            --ar="$AR" \
            --ranlib="$RANLIB" \
            --strip="$STRIP" \
            --nm="$NM" \
            --enable-cross-compile \
            --disable-shared \
            --enable-static \
            --enable-small \
            --disable-programs \
            --disable-doc \
            --disable-htmlpages \
            --disable-manpages \
            --disable-podpages \
            --disable-txtpages \
            --disable-network \
            --disable-protocols \
            --enable-protocol=file \
            --enable-protocol=pipe \
            --enable-encoder=aac \
            --enable-decoder=h264 \
            --enable-decoder=aac \
            --enable-parser=h264 \
            --enable-parser=aac \
            --enable-demuxer=mov \
            --enable-demuxer=mp4 \
            --enable-demuxer=avi \
            --enable-demuxer=wav \
            --enable-muxer=mp4 \
            --enable-muxer=mov \
            --enable-muxer=avi \
            --enable-muxer=wav \
            --extra-cflags="-fPIC -DANDROID -D__ANDROID_API__=$API" \
            --prefix="$FFMPEG_PREFIX"
            
          if [ $? -ne 0 ]; then
            echo "Both configure attempts failed. Exiting."
            exit 1
          else
            echo "Fallback configuration succeeded (basic FFmpeg without external codecs)"
          fi
        else
          echo "Configure succeeded with external codec support"
        fi
        
        echo "Building FFmpeg..."
        make -j$(nproc) || {
          echo "FFmpeg build failed"
          echo "Make output (last 50 lines):"
          make 2>&1 | tail -50
          exit 1
        }
        
        echo "Installing FFmpeg..."
        make install || {
          echo "FFmpeg installation failed"
          exit 1
        }
        
        echo "FFmpeg build and installation completed"
        
    - name: Verify FFmpeg build output
      run: |
        echo "Checking FFmpeg build output..."
        
        if [ ! -d "$FFMPEG_PREFIX/include" ]; then
          echo "ERROR: FFmpeg include directory not found at $FFMPEG_PREFIX/include"
          echo "Contents of FFMPEG_PREFIX directory:"
          ls -la "$FFMPEG_PREFIX/" || echo "FFMPEG_PREFIX directory does not exist"
          exit 1
        fi
        
        if [ ! -d "$FFMPEG_PREFIX/lib" ]; then
          echo "ERROR: FFmpeg lib directory not found at $FFMPEG_PREFIX/lib"
          exit 1
        fi
        
        echo "FFmpeg build verification passed:"
        echo "Headers: $(find "$FFMPEG_PREFIX/include" -name "*.h" | wc -l) files"
        echo "Libraries: $(find "$FFMPEG_PREFIX/lib" -name "*.a" | wc -l) files"
        
        echo "Library files:"
        ls -la "$FFMPEG_PREFIX/lib"/*.a
        
    - name: Create Android project structure
      run: |
        mkdir -p android-project/app/src/main/{cpp,java/com/ffmpeg/library}
        mkdir -p android-project/app/libs
        mkdir -p android-project/gradle/wrapper
        
    - name: Copy FFmpeg libraries and headers
      run: |
        # Copy FFmpeg headers
        cp -r "$FFMPEG_PREFIX/include" android-project/app/src/main/cpp/
        
        # Copy FFmpeg libraries
        cp -r "$FFMPEG_PREFIX/lib" android-project/app/src/main/cpp/
        
        # Copy external dependency libraries if they exist
        if [ -f "$FFMPEG_DEPS_ROOT/lib/libx264.a" ]; then
          cp "$FFMPEG_DEPS_ROOT/lib"/libx264.a android-project/app/src/main/cpp/lib/
        fi
        if [ -f "$FFMPEG_DEPS_ROOT/lib/libopus.a" ]; then
          cp "$FFMPEG_DEPS_ROOT/lib"/libopus.a android-project/app/src/main/cpp/lib/
          cp "$FFMPEG_DEPS_ROOT/lib"/libvorbis.a android-project/app/src/main/cpp/lib/
          cp "$FFMPEG_DEPS_ROOT/lib"/libvorbisenc.a android-project/app/src/main/cpp/lib/
          cp "$FFMPEG_DEPS_ROOT/lib"/libogg.a android-project/app/src/main/cpp/lib/
          cp "$FFMPEG_DEPS_ROOT/lib"/libmp3lame.a android-project/app/src/main/cpp/lib/
        fi
        
        echo "Verifying copied libraries:"
        ls -la android-project/app/src/main/cpp/lib/
        
    - name: Create JNI wrapper
      run: |
        cat > android-project/app/src/main/cpp/ffmpeg_jni.cpp << 'EOF'
        #include <jni.h>
        #include <string>
        #include <android/log.h>
        #include <vector>
        
        extern "C" {
        #include "include/libavcodec/avcodec.h"
        #include "include/libavformat/avformat.h"
        #include "include/libavutil/avutil.h"
        #include "include/libavutil/log.h"
        }
        
        #define LOG_TAG "FFmpegJNI"
        #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
        #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
        
        static void android_log_callback(void* ptr, int level, const char* fmt, va_list vl) {
            int android_level;
            switch (level) {
                case AV_LOG_PANIC:
                case AV_LOG_FATAL:
                case AV_LOG_ERROR:
                    android_level = ANDROID_LOG_ERROR;
                    break;
                case AV_LOG_WARNING:
                    android_level = ANDROID_LOG_WARN;
                    break;
                case AV_LOG_INFO:
                    android_level = ANDROID_LOG_INFO;
                    break;
                case AV_LOG_DEBUG:
                    android_level = ANDROID_LOG_DEBUG;
                    break;
                default:
                    android_level = ANDROID_LOG_VERBOSE;
                    break;
            }
            __android_log_vprint(android_level, LOG_TAG, fmt, vl);
        }
        
        extern "C" JNIEXPORT jint JNICALL
        JNI_OnLoad(JavaVM *vm, void *reserved) {
            av_log_set_callback(android_log_callback);
            LOGI("FFmpeg library loaded");
            return JNI_VERSION_1_6;
        }
        
        extern "C" JNIEXPORT jstring JNICALL
        Java_com_ffmpeg_library_FFmpegLibrary_getFFmpegVersion(JNIEnv *env, jobject thiz) {
            return env->NewStringUTF(av_version_info());
        }
        
        extern "C" JNIEXPORT jstring JNICALL
        Java_com_ffmpeg_library_FFmpegLibrary_getAvcodecConfiguration(JNIEnv *env, jobject thiz) {
            return env->NewStringUTF(avcodec_configuration());
        }
        
        extern "C" JNIEXPORT jboolean JNICALL
        Java_com_ffmpeg_library_FFmpegLibrary_isCodecSupported(JNIEnv *env, jobject thiz, jstring codecName) {
            const char* codec_name = env->GetStringUTFChars(codecName, nullptr);
            const AVCodec* codec = avcodec_find_encoder_by_name(codec_name);
            if (!codec) {
                codec = avcodec_find_decoder_by_name(codec_name);
            }
            env->ReleaseStringUTFChars(codecName, codec_name);
            return codec != nullptr;
        }
        
        extern "C" JNIEXPORT jobjectArray JNICALL
        Java_com_ffmpeg_library_FFmpegLibrary_getSupportedCodecs(JNIEnv *env, jobject thiz) {
            std::vector<std::string> codec_names;
            
            const char* test_codecs[] = {
                "libx264", "h264", "libopus", "opus", 
                "libvorbis", "vorbis", "libmp3lame", "mp3", "aac"
            };
            
            for (const char* codec_name : test_codecs) {
                const AVCodec* codec = avcodec_find_encoder_by_name(codec_name);
                if (!codec) {
                    codec = avcodec_find_decoder_by_name(codec_name);
                }
                if (codec) {
                    codec_names.push_back(codec_name);
                }
            }
            
            jobjectArray result = env->NewObjectArray(codec_names.size(), 
                env->FindClass("java/lang/String"), env->NewStringUTF(""));
            
            for (size_t i = 0; i < codec_names.size(); i++) {
                env->SetObjectArrayElement(result, i, env->NewStringUTF(codec_names[i].c_str()));
            }
            
            return result;
        }
        EOF
        
    - name: Create Java wrapper class
      run: |
        cat > android-project/app/src/main/java/com/ffmpeg/library/FFmpegLibrary.java << 'EOF'
        package com.ffmpeg.library;
        
        public class FFmpegLibrary {
            static {
                System.loadLibrary("ffmpeg-jni");
            }
            
            public native String getFFmpegVersion();
            public native String getAvcodecConfiguration();
            public native boolean isCodecSupported(String codecName);
            public native String[] getSupportedCodecs();
            
            private static FFmpegLibrary instance;
            
            public static synchronized FFmpegLibrary getInstance() {
                if (instance == null) {
                    instance = new FFmpegLibrary();
                }
                return instance;
            }
            
            public boolean hasExternalCodecSupport() {
                return isCodecSupported("libx264") || 
                       isCodecSupported("libopus") || 
                       isCodecSupported("libvorbis") || 
                       isCodecSupported("libmp3lame");
            }
        }
        EOF
        
    - name: Create CMakeLists.txt
      run: |
        cat > android-project/app/src/main/cpp/CMakeLists.txt << 'EOF'
        cmake_minimum_required(VERSION 3.18.1)
        project("ffmpeg-jni")
        
        set(CMAKE_CXX_STANDARD 14)
        set(CMAKE_CXX_STANDARD_REQUIRED ON)
        
        find_library(log-lib log)
        find_library(android-lib android)
        find_library(z-lib z)
        find_library(m-lib m)
        
        set(LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/lib)
        
        # Import FFmpeg libraries
        add_library(avutil STATIC IMPORTED)
        set_target_properties(avutil PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libavutil.a)
            
        add_library(avcodec STATIC IMPORTED)
        set_target_properties(avcodec PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libavcodec.a)
            
        add_library(avformat STATIC IMPORTED)
        set_target_properties(avformat PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libavformat.a)
            
        add_library(swscale STATIC IMPORTED)
        set_target_properties(swscale PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libswscale.a)
            
        add_library(swresample STATIC IMPORTED)
        set_target_properties(swresample PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libswresample.a)
        
        add_library(avfilter STATIC IMPORTED)
        set_target_properties(avfilter PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libavfilter.a)
        
        # Import external codec libraries (if they exist)
        if(EXISTS ${LIB_DIR}/libx264.a)
          add_library(x264 STATIC IMPORTED)
          set_target_properties(x264 PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libx264.a)
          list(APPEND EXTERNAL_LIBS x264)
        endif()
        
        if(EXISTS ${LIB_DIR}/libopus.a)
          add_library(opus STATIC IMPORTED)
          set_target_properties(opus PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libopus.a)
          list(APPEND EXTERNAL_LIBS opus)
        endif()
        
        if(EXISTS ${LIB_DIR}/libvorbis.a)
          add_library(vorbis STATIC IMPORTED)
          set_target_properties(vorbis PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libvorbis.a)
          list(APPEND EXTERNAL_LIBS vorbis)
        endif()
        
        if(EXISTS ${LIB_DIR}/libvorbisenc.a)
          add_library(vorbisenc STATIC IMPORTED)
          set_target_properties(vorbisenc PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libvorbisenc.a)
          list(APPEND EXTERNAL_LIBS vorbisenc)
        endif()
        
        if(EXISTS ${LIB_DIR}/libogg.a)
          add_library(ogg STATIC IMPORTED)
          set_target_properties(ogg PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libogg.a)
          list(APPEND EXTERNAL_LIBS ogg)
        endif()
        
        if(EXISTS ${LIB_DIR}/libmp3lame.a)
          add_library(mp3lame STATIC IMPORTED)
          set_target_properties(mp3lame PROPERTIES IMPORTED_LOCATION ${LIB_DIR}/libmp3lame.a)
          list(APPEND EXTERNAL_LIBS mp3lame)
        endif()
        
        add_library(ffmpeg-jni SHARED ffmpeg_jni.cpp)
        
        target_include_directories(ffmpeg-jni PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include)
        
        target_link_libraries(ffmpeg-jni
            avformat
            avfilter
            avcodec
            swresample
            swscale
            avutil
            ${EXTERNAL_LIBS}
            ${log-lib}
            ${android-lib}
            ${z-lib}
            ${m-lib}
        )
        
        target_compile_options(ffmpeg-jni PRIVATE -Wall -Wextra)
        EOF
        
    - name: Create Android build files
      run: |
        # Create app/build.gradle
        cat > android-project/app/build.gradle << 'EOF'
        plugins {
            id 'com.android.library'
        }
        
        android {
            namespace 'com.ffmpeg.library'
            compileSdk 34
        
            defaultConfig {
                minSdk 24
                targetSdk 34
                
                ndk {
                    abiFilters 'arm64-v8a'
                }
                
                externalNativeBuild {
                    cmake {
                        cppFlags '-std=c++14', '-frtti', '-fexceptions'
                        arguments '-DANDROID_STL=c++_shared'
                        targets 'ffmpeg-jni'
                    }
                }
            }
        
            buildTypes {
                release {
                    minifyEnabled false
                }
                debug {
                    debuggable true
                    jniDebuggable true
                }
            }
            
            externalNativeBuild {
                cmake {
                    path file('src/main/cpp/CMakeLists.txt')
                    version '3.18.1'
                }
            }
            
            compileOptions {
                sourceCompatibility JavaVersion.VERSION_1_8
                targetCompatibility JavaVersion.VERSION_1_8
            }
            
            packagingOptions {
                pickFirst '**/libc++_shared.so'
            }
        }
        EOF
        
        # Create root build.gradle
        cat > android-project/build.gradle << 'EOF'
        plugins {
            id 'com.android.library' version '8.1.4' apply false
        }
        
        allprojects {
            repositories {
                google()
                mavenCentral()
            }
        }
        
        tasks.register('clean', Delete) {
            delete rootProject.buildDir
        }
        EOF
        
        # Create gradle.properties
        cat > android-project/gradle.properties << 'EOF'
        org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
        android.useAndroidX=true
        android.enableJetifier=true
        android.native.buildOutput=verbose
        EOF
        
        # Create settings.gradle
        cat > android-project/settings.gradle << 'EOF'
        pluginManagement {
            repositories {
                google()
                mavenCentral()
                gradlePluginPortal()
            }
        }
        dependencyResolutionManagement {
            repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
            repositories {
                google()
                mavenCentral()
            }
        }
        
        rootProject.name = "FFmpeg Library"
        include ':app'
        EOF
        
        # Create AndroidManifest.xml
        cat > android-project/app/src/main/AndroidManifest.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android">
            <application />
        </manifest>
        EOF
        
        # Create proguard-rules.pro
        cat > android-project/app/proguard-rules.pro << 'EOF'
        -keepclasseswithmembernames class * {
            native <methods>;
        }
        -keep class com.ffmpeg.library.** { *; }
        EOF
        
    # Fixed Gradle Wrapper Setup - Following Best Practices
    - name: Setup Gradle Wrapper (Proper Method)
      run: |
        cd android-project
        
        # Create gradle wrapper directory structure
        mkdir -p gradle/wrapper
        
        # Download gradle-wrapper.jar from official Gradle repository
        echo "Downloading gradle-wrapper.jar..."
        curl -L -o gradle/wrapper/gradle-wrapper.jar \
          "https://services.gradle.org/distributions/gradle-${{ env.GRADLE_VERSION }}-wrapper.jar"
        
        # Verify the JAR was downloaded correctly
        if [ ! -f "gradle/wrapper/gradle-wrapper.jar" ] || [ ! -s "gradle/wrapper/gradle-wrapper.jar" ]; then
          echo "ERROR: gradle-wrapper.jar download failed or file is empty"
          exit 1
        fi
        
        echo "gradle-wrapper.jar downloaded successfully:"
        ls -la gradle/wrapper/gradle-wrapper.jar
        
        # Create gradle-wrapper.properties with correct format
        cat > gradle/wrapper/gradle-wrapper.properties << 'EOF'
        distributionBase=GRADLE_USER_HOME
        distributionPath=wrapper/dists
        distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-bin.zip
        networkTimeout=10000
        validateDistributionUrl=true
        zipStoreBase=GRADLE_USER_HOME
        zipStorePath=wrapper/dists
        EOF
        
        # Create gradlew script with proper error handling and path resolution
        cat > gradlew << 'EOF'
        #!/bin/sh
        
        #
        # Copyright © 2015-2021 the original authors.
        #
        # Licensed under the Apache License, Version 2.0 (the "License");
        # you may not use this file except in compliance with the License.
        # You may obtain a copy of the License at
        #
        #      https://www.apache.org/licenses/LICENSE-2.0
        #
        # Unless required by applicable law or agreed to in writing, software
        # distributed under the License is distributed on an "AS IS" BASIS,
        # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        # See the License for the specific language governing permissions and
        # limitations under the License.
        #
        
        ##############################################################################
        #
        #   Gradle start up script for POSIX generated by Gradle.
        #
        #   Important for running:
        #
        #   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
        #       noncompliant, but you have some other compliant shell such as ksh or
        #       bash, then to run this script, type that shell name before the whole
        #       command line, like:
        #
        #           ksh Gradle
        #
        #       Busybox and similar reduced shells will NOT work, because this script
        #       requires all of these POSIX shell features:
        #         * functions;
        #         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
        #           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
        #         * compound commands having a testable exit status, especially «case»;
        #         * various built-in commands including «command», «set», and «ulimit».
        #
        #   Important for patching:
        #
        #   (2) This script targets any POSIX shell, so it avoids extensions provided
        #       by Bash, Ksh, etc; in particular arrays are avoided.
        #
        #       The "traditional" practice of packing multiple parameters into a
        #       space-separated string is a well documented source of bugs and security
        #       problems, so this is (mostly) avoided, by progressively accumulating
        #       options in "$@", and eventually passing that to Java.
        #
        #       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
        #       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
        #       see the in-line comments for details.
        #
        #       There are tweaks for specific operating systems such as AIX, CygWin,
        #       Darwin, MinGW, and NonStop.
        #
        #   (3) This script is generated from the Gradle template within the Gradle project.
        #
        #       You can find Gradle at https://github.com/gradle/gradle/.
        #
        ##############################################################################
        
        # Attempt to set APP_HOME
        
        # Resolve links: $0 may be a link
        app_path=$0
        
        # Need this for daisy-chained symlinks.
        while
            APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
            [ -h "$app_path" ]
        do
            ls=$( ls -ld "$app_path" )
            link=${ls#*' -> '}
            case $link in             #(
              /*)   app_path=$link ;; #(
              *)    app_path=$APP_HOME$link ;;
            esac
        done
        
        # This is normally unused
        # shellcheck disable=SC2034
        APP_BASE_NAME=${0##*/}
        APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit
        
        # Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
        DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
        
        # Use the maximum available, or set MAX_FD != -1 to use that value.
        MAX_FD=maximum
        
        warn () {
            echo "$*"
        } >&2
        
        die () {
            echo
            echo "$*"
            echo
            exit 1
        } >&2
        
        # OS specific support (must be 'true' or 'false').
        cygwin=false
        msys=false
        darwin=false
        nonstop=false
        case "$( uname )" in                #(
          CYGWIN* )         cygwin=true  ;; #(
          Darwin* )         darwin=true  ;; #(
          MSYS* | MINGW* )  msys=true    ;; #(
          NONSTOP* )        nonstop=true ;;
        esac
        
        if [ "$cygwin" = "true" ] ; then
            APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
            CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
            
            JAVACMD=$( cygpath --unix "$JAVACMD" )
        
            # Now convert the arguments - kludge to limit ourselves to /bin/sh
            for arg do
                if
                    case $arg in                                #(
                      -*)   false ;;                            # don't mess with options #(
                      /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                            [ -e "$t" ] ;;                      #(
                      *)    false ;;
                    esac
                then
                    arg=$( cygpath --path --ignore --mixed "$arg" )
                fi
                # Roll the args list around exactly as many times as the number of
                # args, so each arg winds up back in the position where it started, but
                # possibly modified.
                #
                # NB: a `for` loop captures its iteration list before it begins, so
                # changing the positional parameters here affects neither the number of
                # iterations, nor the values presented in `arg`.
                shift                   # remove old arg
                set -- "$@" "$arg"      # push replacement arg
            done
        fi
        
        # Collect all arguments for the java command;
        #   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
        #     shell script including quotes and variable substitutions, so put them in
        #     double quotes to make sure that they get re-expanded; and
        #   * put everything else in single quotes, so that it's not re-expanded.
        
        set -- \
                "-Dorg.gradle.appname=$APP_BASE_NAME" \
                -classpath "$CLASSPATH" \
                org.gradle.wrapper.GradleWrapperMain \
                "$@"
        
        # Stop when "xargs" is not available.
        if ! command -v xargs >/dev/null 2>&1
        then
            die "xargs is not available"
        fi
        
        # Use "xargs" to parse quoted args.
        #
        # With -n1 it outputs one arg per line, with the quotes and backslashes removed.
        #
        # In Bash we could simply go:
        #
        #   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
        #   set -- "${ARGS[@]}" "$@"
        #
        # but POSIX shell has neither arrays nor command substitution, so instead we
        # post-process each arg (as a line of input to sed) to backslash-escape any
        # character that might be a shell metacharacter, then use eval to reverse
        # that process (while maintaining the separation between arguments).
        #
        # If the command above didn't work, good luck fixing this.
        if [ -n "$JAVA_HOME" ] ; then
            if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                # IBM's JDK on AIX uses strange locations for the executables
                JAVACMD=$JAVA_HOME/jre/sh/java
            else
                JAVACMD=$JAVA_HOME/bin/java
            fi
            if [ ! -x "$JAVACMD" ] ; then
                die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
        
        Please set the JAVA_HOME variable in your environment to match the
        location of your Java installation."
            fi
        else
            JAVACMD=java
            which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
        
        Please set the JAVA_HOME variable in your environment to match the
        location of your Java installation."
        fi
        
        # Increase the maximum file descriptors if we can.
        if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
            case $MAX_FD in #(
              max*)
                # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
                # shellcheck disable=SC3045 
                MAX_FD=$( ulimit -H -n ) ||
                    warn "Could not query maximum file descriptor limit"
            esac
            case $MAX_FD in  #(
              '' | soft) :;; #(
              *)
                # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
                # shellcheck disable=SC3045 
                ulimit -n "$MAX_FD" ||
                    warn "Could not set maximum file descriptor limit to $MAX_FD"
            esac
        fi
        
        # Collect all arguments for the java command, stacking in reverse order:
        #   * args from the command line
        #   * the main class name
        #   * -classpath
        #   * -D...appname settings
        #   * --module-path (only if needed)
        #   * DEFAULT_JVM_OPTS, JAVA_OPTS, GRADLE_OPTS
        
        # For Cygwin or MSYS, switch paths to Windows format before running java
        if "$cygwin" || "$msys" ; then
            APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
            CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
            
            JAVACMD=$( cygpath --unix "$JAVACMD" )
        
            # Now convert the arguments - kludge to limit ourselves to /bin/sh
            for arg do
                if
                    case $arg in                                #(
                      -*)   false ;;                            # don't mess with options #(
                      /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                            [ -e "$t" ] ;;                      #(
                      *)    false ;;
                    esac
                then
                    arg=$( cygpath --path --ignore --mixed "$arg" )
                fi
                # Roll the args list around exactly as many times as the number of
                # args, so each arg winds up back in the position where it started, but
                # possibly modified.
                #
                # NB: a `for` loop captures its iteration list before it begins, so
                # changing the positional parameters here affects neither the number of
                # iterations, nor the values presented in `arg`.
                shift                   # remove old arg
                set -- "$@" "$arg"      # push replacement arg
            done
        fi
        
        # For security reasons, use the maximum available, or set MAX_FD != -1 to use that value.
        if [ "$cygwin" = "false" ] && [ "$darwin" = "false" ] && [ "$nonstop" = "false" ] ; then
            case $MAX_FD in #(
              max*)
                MAX_FD=$( ulimit -H -n ) ||
                    warn "Could not query maximum file descriptor limit"
            esac
            case $MAX_FD in  #(
              '' | soft) :;; #(
              *)
                ulimit -n "$MAX_FD" ||
                    warn "Could not set maximum file descriptor limit to $MAX_FD"
            esac
        fi
        
        # Don't use long-running processes here.
        CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
        
        
        # Determine the Java command to use to start the JVM.
        if [ -n "$JAVA_HOME" ] ; then
            if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                # IBM's JDK on AIX uses strange locations for the executables
                JAVACMD="$JAVA_HOME/jre/sh/java"
            else
                JAVACMD="$JAVA_HOME/bin/java"
            fi
            if [ ! -x "$JAVACMD" ] ; then
                die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
        
        Please set the JAVA_HOME variable in your environment to match the
        location of your Java installation."
            fi
        else
            JAVACMD="java"
            which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
        
        Please set the JAVA_HOME variable in your environment to match the
        location of your Java installation."
        fi
        
        exec "$JAVACMD" "$@"
        EOF
        
        # Make gradlew executable
        chmod +x gradlew
        
        # Create gradlew.bat for Windows compatibility (even though not used in CI)
        cat > gradlew.bat << 'EOF'
        @rem
        @rem Copyright 2015 the original author or authors.
        @rem
        @rem Licensed under the Apache License, Version 2.0 (the "License");
        @rem you may not use this file except in compliance with the License.
        @rem You may obtain a copy of the License at
        @rem
        @rem      https://www.apache.org/licenses/LICENSE-2.0
        @rem
        @rem Unless required by applicable law or agreed to in writing, software
        @rem distributed under the License is distributed on an "AS IS" BASIS,
        @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        @rem See the License for the specific language governing permissions and
        @rem limitations under the License.
        @rem
        
        @if "%DEBUG%"=="" @echo off
        @rem ##########################################################################
        @rem
        @rem  Gradle startup script for Windows
        @rem
        @rem ##########################################################################
        
        @rem Set local scope for the variables with windows NT shell
        if "%OS%"=="Windows_NT" setlocal
        
        set DIRNAME=%~dp0
        if "%DIRNAME%"=="" set DIRNAME=.
        set APP_BASE_NAME=%~n0
        set APP_HOME=%DIRNAME%
        
        @rem Resolve any "." and ".." in APP_HOME to make it shorter.
        for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
        
        @rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
        set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
        
        @rem Find java.exe
        if defined JAVA_HOME goto findJavaFromJavaHome
        
        set JAVA_EXE=java.exe
        %JAVA_EXE% -version >NUL 2>&1
        if %ERRORLEVEL% equ 0 goto execute
        
        echo.
        echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
        echo.
        echo Please set the JAVA_HOME variable in your environment to match the
        echo location of your Java installation.
        
        goto fail
        
        :findJavaFromJavaHome
        set JAVA_HOME=%JAVA_HOME:"=%
        set JAVA_EXE=%JAVA_HOME%/bin/java.exe
        
        if exist "%JAVA_EXE%" goto execute
        
        echo.
        echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
        echo.
        echo Please set the JAVA_HOME variable in your environment to match the
        echo location of your Java installation.
        
        goto fail
        
        :execute
        @rem Setup the command line
        
        set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
        
        
        @rem Execute Gradle
        "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
        
        :end
        @rem End local scope for the variables with windows NT shell
        if %ERRORLEVEL% equ 0 goto mainEnd
        
        :fail
        rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
        rem the _cmd_ return code.
        if not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
        exit /b 1
        
        :mainEnd
        if "%OS%"=="Windows_NT" endlocal
        
        :omega
        EOF
        
        # Verify setup
        echo "Gradle wrapper setup completed:"
        echo "- gradlew script: $(ls -la gradlew)"
        echo "- gradle-wrapper.jar: $(ls -la gradle/wrapper/gradle-wrapper.jar)"
        echo "- gradle-wrapper.properties: $(ls -la gradle/wrapper/gradle-wrapper.properties)"
        
        # Test Java availability
        echo "Testing Java availability:"
        java -version
        
        # Test gradlew script without running actual build
        echo "Testing gradlew script execution:"
        ./gradlew --version
        
    - name: Build AAR with proper error handling
      run: |
        cd android-project
        
        # Set JAVA_HOME explicitly if not set
        if [ -z "$JAVA_HOME" ]; then
          export JAVA_HOME="/opt/hostedtoolcache/Java_Temurin-Hotspot_jdk/17.0.12-7/x64"
          echo "JAVA_HOME set to: $JAVA_HOME"
        fi
        
        # Add some debugging information
        echo "=== Build Environment ==="
        echo "PWD: $(pwd)"
        echo "JAVA_HOME: $JAVA_HOME"
        echo "Java version: $(java -version)"
        echo "Gradle wrapper version:"
        ./gradlew --version
        echo "=========================="
        
        # Clean any previous builds
        echo "Cleaning previous builds..."
        ./gradlew clean --stacktrace
        
        # Build with detailed logging
        echo "Building AAR..."
        ./gradlew assembleRelease --stacktrace --info --debug
        
    - name: Verify AAR contents
      run: |
        cd android-project
        AAR_FILE=$(find app/build/outputs/aar -name "*.aar" | head -1)
        if [ -f "$AAR_FILE" ]; then
          echo "AAR file found: $AAR_FILE"
          echo "AAR file size: $(du -h "$AAR_FILE" | cut -f1)"
          echo ""
          echo "AAR contents:"
          unzip -l "$AAR_FILE"
          echo ""
          echo "Checking for native libraries:"
          unzip -l "$AAR_FILE" | grep "\.so$" || echo "No .so files found in AAR"
          
          mkdir -p aar-check
          cd aar-check
          unzip -q "../$AAR_FILE"
          
          if [ -f "jni/arm64-v8a/libffmpeg-jni.so" ]; then
            echo ""
            echo "Native library found in AAR:"
            ls -la jni/arm64-v8a/libffmpeg-jni.so
          else
            echo "ERROR: Native library not found in AAR!"
            find . -name "*.so" | head -5
          fi
          cd ..
        else
          echo "AAR file not found!"
          find app/build -name "*.aar" -o -name "*.so" | head -10
          exit 1
        fi
        
    - name: Create usage documentation
      run: |
        cat > android-project/USAGE_EXAMPLE.md << 'EOF'
        # FFmpeg Android Library Usage
        
        This AAR contains FFmpeg compiled for Android ARM64 with potential external codec support.
        
        ## Integration
        
        1. Add the AAR to your Android project's `app/libs/` directory
        2. In your `app/build.gradle`, add:
        ```gradle
        dependencies {
            implementation files('libs/app-release.aar')
        }
        ```
        
        ## Basic Usage
        
        ```java
        import com.ffmpeg.library.FFmpegLibrary;
        
        public class MainActivity extends AppCompatActivity {
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                
                FFmpegLibrary ffmpeg = FFmpegLibrary.getInstance();
                
                // Check FFmpeg version
                String version = ffmpeg.getFFmpegVersion();
                Log.i("FFmpeg", "Version: " + version);
                
                // Check external codec support
                boolean hasExternalCodecs = ffmpeg.hasExternalCodecSupport();
                Log.i("FFmpeg", "External codecs available: " + hasExternalCodecs);
                
                // Check specific codec support
                boolean h264Supported = ffmpeg.isCodecSupported("libx264");
                boolean opusSupported = ffmpeg.isCodecSupported("libopus");
                boolean aacSupported = ffmpeg.isCodecSupported("aac");
                
                Log.i("FFmpeg", "H.264 (x264): " + h264Supported);
                Log.i("FFmpeg", "Opus: " + opusSupported);
                Log.i("FFmpeg", "AAC: " + aacSupported);
                
                // Get all supported codecs
                String[] supportedCodecs = ffmpeg.getSupportedCodecs();
                Log.i("FFmpeg", "Supported codecs: " + Arrays.toString(supportedCodecs));
                
                // Get configuration details
                String config = ffmpeg.getAvcodecConfiguration();
                Log.i("FFmpeg", "Configuration: " + config);
            }
        }
        ```
        
        ## Available Methods
        
        - `getFFmpegVersion()` - Returns FFmpeg version string
        - `getAvcodecConfiguration()` - Returns build configuration
        - `isCodecSupported(String codecName)` - Check if specific codec is available
        - `getSupportedCodecs()` - Get array of supported codecs
        - `hasExternalCodecSupport()` - Quick check for external codec availability
        
        ## Codec Names for Testing
        
        Common codec names to test with `isCodecSupported()`:
        - `"libx264"` - H.264 video encoder (if external codecs built successfully)
        - `"h264"` - H.264 video decoder
        - `"libopus"` - Opus audio encoder (if external codecs built successfully)
        - `"opus"` - Opus audio decoder
        - `"aac"` - AAC audio encoder/decoder (built-in)
        - `"mp3"` - MP3 audio decoder
        
        ## Notes
        
        - External codec support depends on successful compilation during build
        - If external codecs fail to build, the library falls back to basic FFmpeg functionality
        - Check the build logs to see which codecs were successfully included
        EOF
        
    - name: Upload AAR artifact
      uses: actions/upload-artifact@v4
      with:
        name: ffmpeg-aar-arm64-${{ env.FFMPEG_VERSION }}
        path: |
          android-project/app/build/outputs/aar/*.aar
          android-project/USAGE_EXAMPLE.md
        retention-days: 30
        
    - name: Create build summary
      run: |
        echo "## 🎉 FFmpeg AAR Build Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "✅ **FFmpeg ${{ env.FFMPEG_VERSION }} built successfully for Android ARM64**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📱 Target Platform" >> $GITHUB_STEP_SUMMARY
        echo "- **Android:** API ${{ env.ANDROID_API_LEVEL }}+ (Android 7.0+)" >> $GITHUB_STEP_SUMMARY
        echo "- **Architecture:** ${{ env.ANDROID_ABI }} (ARM64 only)" >> $GITHUB_STEP_SUMMARY
        echo "- **NDK Version:** ${{ env.ANDROID_NDK_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        cd android-project
        AAR_FILE=$(find app/build/outputs/aar -name "*.aar" | head -1)
        if [ -f "$AAR_FILE" ]; then
          AAR_SIZE=$(du -h "$AAR_FILE" | cut -f1)
          echo "### 📦 Output" >> $GITHUB_STEP_SUMMARY
          echo "- **AAR File:** $(basename "$AAR_FILE")" >> $GITHUB_STEP_SUMMARY
          echo "- **Size:** $AAR_SIZE" >> $GITHUB_STEP_SUMMARY
          echo "- **External Codec Support:** Check build logs for details" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📋 Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Download the AAR from build artifacts" >> $GITHUB_STEP_SUMMARY
        echo "2. Check USAGE_EXAMPLE.md for integration instructions" >> $GITHUB_STEP_SUMMARY
        echo "3. Use the provided methods to test codec availability" >> $GITHUB_STEP_SUMMARY
